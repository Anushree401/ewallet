'''
FastAPI application setup with all endpoints
'''

from fastapi import FastAPI, Depends, HTTPException, status
from uuid import UUID
from typing import List 
from contextlib import asynccontextmanager
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    from database import init_db
    init_db()
    yield

app = FastAPI(
    title="E-Commerce API",
    description="A simple e-commerce API with user wallet functionality",
    version="1.0.0",
    lifespan=lifespan
)

# Now import other modules AFTER the lifespan definition
from models import User, Transaction
from schema import (
    UserCreateSchema, UserLoginSchema, UserSchema,
    SpendMoneySchema, ItemCreateSchema, ItemSchema,
    TransferMoneySchema, TopUpWalletSchema, TransactionSchema
)
from crud import (
    create_user, get_user_by_username, list_items, spend_money,
    buy_item, add_item, top_up_wallet, transfer_money,
    get_user_transactions, get_item_by_id
)
from auth import (
    verify_password, create_access_token, get_current_user,
    get_current_admin_user
)

# auth endpt 
@app.post("/auth/register", response_model=UserSchema, status_code=status.HTTP_201_CREATED)
def register(user: UserCreateSchema):
    try:
        user_data = create_user(
            username=user.username,
            password=user.password,
            role=user.role or "user"  
        )
        
        return UserSchema(**user_data)
        
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Registration failed: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user"
        )

@app.post("/auth/login")
def login(user: UserLoginSchema):
    db_user = get_user_by_username(user.username)
    if not db_user or not verify_password(user.password, db_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    access_token = create_access_token(
        data={"sub": db_user.username, "role": db_user.role}
    )
    return {"access_token": access_token, "token_type": "bearer"}

# user endpt 
@app.get("/users/me", response_model=UserSchema)
def read_users_me(current_user: User = Depends(get_current_user)):
    return UserSchema(
        id=current_user.id,
        username=current_user.username,
        wallet_bal=current_user.wallet_bal,
        role=current_user.role
    )

@app.get("/wallet/balance", response_model=float)
def get_balance(current_user: User = Depends(get_current_user)):
    return current_user.wallet_bal

@app.post("/wallet/top-up", response_model=UserSchema)
def top_up_wallet_endpoint(
    request: TopUpWalletSchema,
    current_user: User = Depends(get_current_user)
):
    user, transaction = top_up_wallet(current_user.id, request.amount)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Failed to top up wallet"
        )
    
    return UserSchema(
        id=user.id,
        username=user.username,
        wallet_bal=user.wallet_bal,
        role=user.role
    )

@app.post("/wallet/spend", response_model=UserSchema)
def spend_endpoint(
    request: SpendMoneySchema,
    current_user: User = Depends(get_current_user)
):
    user, transaction = spend_money(current_user.id, request.amount)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Insufficient funds"
        )
    
    return UserSchema(
        id=user.id,
        username=user.username,
        wallet_bal=user.wallet_bal,
        role=user.role
    )

@app.post("/wallet/transfer", response_model=dict)
def transfer_money_endpoint(
    request: TransferMoneySchema,
    current_user: User = Depends(get_current_user)
):
    sender, recipient, transaction = transfer_money(
        current_user.id,
        request.recipient_username,
        request.amount
    )
    
    if not sender or not recipient:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Transfer failed: insufficient funds, invalid recipient, or self-transfer not allowed"
        )
    
    return {
        "message": "Transfer successful",
        "sender_balance": sender.wallet_bal,
        "recipient": recipient.username
    }

@app.get("/transactions", response_model=List[TransactionSchema])
def get_transactions(current_user: User = Depends(get_current_user)):
    transactions = get_user_transactions(current_user.id)
    return [
        TransactionSchema(
            id=transaction.id,
            user_id=transaction.user_id,
            product_id=transaction.product_id,
            amount=transaction.amount,
            timestamp=transaction.timestamp,
            type=transaction.type
        ) for transaction in transactions
    ]

# Item Endpoints
@app.get("/items", response_model=List[ItemSchema])
def get_items():
    items = list_items()
    return [
        ItemSchema(
            id=item.id,
            name=item.name,
            price=item.price,
            stock_val=item.stock_val
        ) for item in items
    ]

@app.get("/items/{item_id}", response_model=ItemSchema)
def get_item(item_id: UUID):
    item = get_item_by_id(item_id)
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Item not found"
        )
    return ItemSchema(
        id=item.id,
        name=item.name,
        price=item.price,
        stock_val=item.stock_val
    )

@app.post("/items/buy/{item_id}", response_model=dict)
def buy_item_endpoint(
    item_id: UUID,
    current_user: User = Depends(get_current_user)
):
    user, item, transaction = buy_item(current_user.id, item_id)
    if not transaction or not user or not item:  # Add checks for user and item
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Purchase failed: insufficient balance, out of stock, or invalid item"
        )
    
    return {
        "message": "Purchase successful",
        "user": UserSchema(
            id=user.id,
            username=user.username,
            wallet_bal=user.wallet_bal,
            role=user.role
        ),
        "item": ItemSchema(
            id=item.id,
            name=item.name,
            price=item.price,
            stock_val=item.stock_val
        ),
        "transaction": TransactionSchema(
            id=transaction.id,
            user_id=transaction.user_id,
            product_id=transaction.product_id,
            amount=transaction.amount,
            timestamp=transaction.timestamp,
            type=transaction.type
        )
    }

# admin endpt
@app.post("/admin/items", response_model=ItemSchema, status_code=status.HTTP_201_CREATED)
def create_item(
    item: ItemCreateSchema,
    current_user: User = Depends(get_current_admin_user)
):
    try:
        new_item = add_item(item.name, item.price, item.stock_val)
        return ItemSchema(
            id=new_item.id,
            name=new_item.name,
            price=new_item.price,
            stock_val=new_item.stock_val
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create item"
        )

@app.get("/admin/users", response_model=List[UserSchema])
def list_all_users(current_user: User = Depends(get_current_admin_user)):
    from .crud import list_users
    users = list_users()
    return [
        UserSchema(
            id=user.id,
            username=user.username,
            wallet_bal=user.wallet_bal,
            role=user.role
        ) for user in users
    ]

# health check
@app.get("/health")
def health_check():
    return {"status": "healthy", "message": "API is running"}

# debugging
@app.post("/test-db")
def test_db_operation():
    from .database import get_session
    from sqlmodel import select
    
    try:
        with get_session() as session:
            # Test a simple query
            result = session.exec(select(1))
            return {"status": "Database connection working", "test_query": result.first()}
    except Exception as e:
        return {"status": "Database error", "error": str(e)}
@app.get("/test-get-user/{username}")
def test_get_user(username: str):
    from .crud import get_user_by_username
    user = get_user_by_username(username)
    if user:
        return {
            "exists": True,
            "id": str(user.id),
            "username": user.username,
            "wallet_bal": user.wallet_bal,
            "role": user.role
        }
    else:
        return {"exists": False}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)